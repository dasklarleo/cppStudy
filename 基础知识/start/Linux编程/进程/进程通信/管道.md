---
typora-root-url: ../img
---

# 管道

## 概念

管道是一种最基本的**IPC（进程通信）**机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道

特质：

- 管道的本质是一块内核缓冲区 
-  由两个文件描述符引用，一个表示读端，一个表示写端
  - 由read和write进行操作
- 规定数据从管道的写端流入管道，从读端流出
-  当两个进程都终结的时候，管道也自动消失
- 管道的读端和写端默认都是阻塞的

## 原理

- 管道的实质是内核缓冲区，内部使用环形队列实现
- 默认缓冲区大小为4K，可以使用ulimit -a命令获取大小
- 实际操作过程中缓冲区会根据数据压力做适当调整

## 局限性

- 读了就咩了
- 数据只可以在一个方向流动，双向流动必须要使用两个管道
- 只能在有血缘关系的进程之间使用管道

## 管道创建函数

- 函数作用:
  - 创建一个管道
- 函数原型:
  - int pipe(int fd[2]);
- 函数参数:
  - 若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端
-  返回值:
  - 成功返回0；
  - 失败返回-1，并设置errno值。

## 父子进程之间的通信

一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在血缘关系，这里的血缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。**父子进程间具有相同的文件描述符，且指向同一个管道**pipe，其他没有关系的进程不能获得pipe（）产生的两个文件描述符，也就不能利用同一个管道进行通信。

1. 第一步：父进程创建管道
   ![image-20210125094019866](/../进程通信/image-20210125094019866.png)
2. 父进程fork子进程
   ![image-20210125094058082](/../进程通信/image-20210125094058082.png)
3. 父进程关闭fd[0]，子进程关闭fd[1]
   ![image-20210125094135117](/../进程通信/image-20210125094135117.png)

**创建步骤总结：**

- 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]和fd[1]，分别指向管道的读端和写端
- 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管
- 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出，这样就实现了父子进程间通信。

**示例代码**

```c++
#include <iostream>
#include <string>
#include <unistd.h>

using namespace std;

int main(){
    char buf[64];
    //创建管道
    int fd[2];
    int ret=pipe(fd);
    if(ret<0){
        perror("pipe error");
    }
    //
    pid_t pid=fork();//创建子进程
    if(pid<0)
        perror("fork error");
    else if (pid>0){
        cout<<"Parent"<<endl;
        close(fd[0]);//父进程关闭一端
        while (true){
            sleep(1);
            write(fd[1],"hello",5);
            cout<<"i write"<<endl;
        }

        wait(NULL);
    } else{
        cout<<"Child"<<endl;
        close(fd[1]);//子进程关闭一端
        while (true){
            read(fd[0],buf,5);//阻塞
            cout<<"i read";
            cout<<buf<<endl;
        }

    }
}
```

## 读写行为

- 读操作
  - 有数据：read正常读，返回读出的字节数
  - 无数据：
    - 写端全部关闭
      - read解除阻塞，返回0, 相当于读文件读到了尾部
    - 没有全部关闭
      - read阻塞
-  写操作
  - 读端全部关闭
    - 管道破裂，进程终止, 内核给当前进程发SIGPIPE信号
  - 读端没全部关闭
    - 缓冲区写满了：write阻塞
    - 缓冲区没有满：继续write